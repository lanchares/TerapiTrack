{% extends "base.html" %}

{% block title %}Sesi√≥n en Curso - TerapiTrack{% endblock %}

{% block content %}
<div class="container-fluid p-0" style="height: 100vh; background: #000;">
    <div class="row g-0 h-100">
        <!-- Video demostraci√≥n (50% - izquierda) -->
        <div class="col-md-6 h-100 position-relative">
            <div class="h-100 d-flex flex-column" style="min-height:0;">
                <!-- Header del video demo -->
                <div class="bg-primary text-white p-3 text-center">
                    <h4 class="mb-0" id="ejercicioNombre">Esperando al profesional...</h4>
                    <small id="ejercicioTipo" class="text-light"></small>
                </div>

                <!-- Video demostrativo -->
                <div class="flex-grow-1 position-relative" style="min-height:0;">
                    <video id="demoVideo" controls autoplay muted loop
                           class="w-100 h-100"
                           style="object-fit: cover; background: #1a1a1a; max-height:100%;">
                        <source src="" type="video/mp4">
                        Tu navegador no soporta videos.
                    </video>

                    <!-- Overlay cuando no hay video -->
                    <div id="waitingOverlay" class="position-absolute top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center bg-dark bg-opacity-75">
                        <div class="text-center text-white">
                            <div class="spinner-border text-primary mb-3" role="status">
                                <span class="visually-hidden">Cargando...</span>
                            </div>
                            <h5>Esperando al profesional</h5>
                            <p class="text-muted">Tu terapeuta iniciar√° la sesi√≥n en breve</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- C√°mara del paciente (50% - derecha) -->
        <div class="col-md-6 h-100 position-relative">
            <div class="h-100 d-flex flex-column">
                <!-- Header de la c√°mara -->
                <div class="bg-success text-white p-3 text-center">
                    <h4 class="mb-0">Tu ejecuci√≥n</h4>
                    <div id="recordingStatus" class="d-none">
                        <span class="recording-dot"></span>
                        <small>GRABANDO</small>
                    </div>
                </div>

                <!-- C√°mara del paciente -->
                <div class="flex-grow-1 position-relative">
                    <video id="cameraPreview" autoplay playsinline muted
                           class="w-100 h-100"
                           style="object-fit: cover; background: #1a1a1a;"></video>

                    <!-- Timer de grabaci√≥n -->
                    <div id="timerDisplay" class="position-absolute top-0 end-0 bg-dark bg-opacity-75 text-white p-2 rounded-bottom-start d-none">
                        <i class="bi bi-stopwatch me-1"></i>
                        <span id="timer">00:00</span>
                    </div>
                </div>

                <!-- Estado del mando -->
                <div class="bg-dark text-white p-2">
                    <div class="d-flex justify-content-center">
                        <div class="mini-snes-controller">
                            <!-- Colores correctos: Y verde, X azul, B amarillo, A roja -->
                            <div class="mini-snes-button" id="mini-y" style="background: #4CAF50;">Y</div>
                            <div class="mini-snes-button" id="mini-x" style="background: #2196F3;">X</div>
                            <div class="mini-snes-button" id="mini-b" style="background: #FFC107;">B</div>
                            <div class="mini-snes-button" id="mini-a" style="background: #F44336;">A</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bot√≥n de salida (solo visible si no est√° en sesi√≥n activa) -->
    <div class="position-absolute top-0 end-0 p-3" id="exitButton">
        <a href="{{ url_for('paciente.dashboard') }}" class="btn btn-outline-light">
            <i class="bi bi-x-lg"></i>
        </a>
    </div>
</div>

<style>
    .recording-dot {
        display: inline-block;
        width: 8px;
        height: 8px;
        background-color: #dc3545;
        border-radius: 50%;
        margin-right: 8px;
        animation: blink 1s infinite;
    }
   
    @keyframes blink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0.3; }
    }
   
    .mini-snes-controller {
        display: flex;
        gap: 8px;
        align-items: center;
    }
   
    .mini-snes-button {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 0.7rem;
        font-weight: bold;
        transition: transform 0.1s;
        opacity: 0.6;
    }
   
    .mini-snes-button.active {
        opacity: 1;
        transform: scale(1.2);
    }
</style>

{% block scripts %}
<script>
document.addEventListener("DOMContentLoaded", function() {
    // Elementos DOM
    const cameraPreview = document.getElementById('cameraPreview');
    const demoVideo = document.getElementById('demoVideo');
    const ejercicioNombre = document.getElementById('ejercicioNombre');
    const ejercicioTipo = document.getElementById('ejercicioTipo');
    const recordingStatus = document.getElementById('recordingStatus');
    const timerDisplay = document.getElementById('timerDisplay');
    const timer = document.getElementById('timer');
    const waitingOverlay = document.getElementById('waitingOverlay');

    // Mini mando visual
    const miniButtons = {
        'Y': document.getElementById('mini-y'),
        'X': document.getElementById('mini-x'),
        'B': document.getElementById('mini-b'),
        'A': document.getElementById('mini-a')
    };

    // Datos de ejercicios y sesi√≥n
    const ejercicios = {{ ejercicios_json|tojson }};
    const sesionId = {{ sesion.Id }};
   
    console.log("Ejercicios cargados del paciente:", ejercicios);
    console.log("Sesi√≥n ID:", sesionId);

    // Variables de estado
    let isSessionActive = false;
    let mediaRecorder = null;
    let recordedChunks = [];
    let startTime;
    let timerInterval;
    let currentExercise = -1;       // √≠ndice en el array
    let currentExerciseId = null;   // Id de Ejercicio_Sesion que marca el profesional
    let totalExercises = ejercicios.length;

    // Estabilidad del id enviado por el profesional
    let ultimoEjercicioRecibido = null;   // √∫ltimo id ya aceptado
    let candidatoId = null;               // id que se est√° estabilizando
    let pollsMismoId = 0;                 // n¬∫ de polls seguidos viendo candidatoId
    const REQUIRED_STABLE_POLLS = 2;
    const MIN_CHANGE_INTERVAL = 8000;     // 8 s entre cambios aceptados
    let lastChangeTime = 0;
    let cambioEnProceso = false;

    // Evitar subidas duplicadas simult√°neas
    let isUploading = false;

    // Ejercicios ya completados (v√≠deo subido)
    let ejerciciosCompletados = new Set();

    // Ejercicios para los que ya se ha iniciado una subida en esta sesi√≥n
    let ejerciciosSubidosEnEstaSesion = new Set();

    // Flag para evitar m√∫ltiples stops por la misma grabaci√≥n
    let stopAlreadyCalled = false;

    // NUEVO: bloquear cambios de ejercicio mientras se graba
    let lockCambioEjercicio = false;

    // Estado del gamepad
    let gamepadIndex = null;
    let lastButtonStates = { Y: false, X: false, B: false, A: false };

    // Inicializar c√°mara, mando y polling
    initCamera();
    initGamepad();
    startPollingEstadoSesion();

    async function initCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 1280, height: 720 },
                audio: true
            });
            cameraPreview.srcObject = stream;
            console.log("C√°mara inicializada correctamente");
        } catch (err) {
            console.error("Error al acceder a la c√°mara:", err);
            showAlert("Error al acceder a la c√°mara. Verifica los permisos.");
        }
    }

    // Gamepad: solo indicador visual y Y para volver mientras no hay sesi√≥n activa
    function initGamepad() {
        window.addEventListener('gamepadconnected', (e) => {
            gamepadIndex = e.gamepad.index;
            console.log('üéÆ Mando conectado (ejecutar_sesion):', e.gamepad.id);
            requestAnimationFrame(pollGamepad);
        });

        window.addEventListener('gamepaddisconnected', () => {
            console.log('üéÆ Mando desconectado (ejecutar_sesion)');
            gamepadIndex = null;
            Object.values(miniButtons).forEach(btn => btn && btn.classList.remove('active'));
        });
    }

    function pollGamepad() {
        if (gamepadIndex === null) return;

        const pads = navigator.getGamepads();
        const gp = pads[gamepadIndex];
        if (!gp) {
            requestAnimationFrame(pollGamepad);
            return;
        }

        // Mapping adaptado a tu mando: 0=X, 1=A, 2=B, 3=Y
        const btnX = gp.buttons[0]?.pressed || false;
        const btnA = gp.buttons[1]?.pressed || false;
        const btnB = gp.buttons[2]?.pressed || false;
        const btnY = gp.buttons[3]?.pressed || false;

        const states = { A: btnA, B: btnB, X: btnX, Y: btnY };

        // Actualizar mini-mando visual
        Object.keys(miniButtons).forEach(letter => {
            const el = miniButtons[letter];
            if (!el) return;
            if (states[letter]) el.classList.add('active');
            else el.classList.remove('active');
        });

        // Mientras la sesi√≥n no est√° activa, permitir volver con Y
        if (!isSessionActive && states.Y && !lastButtonStates.Y) {
            window.location.href = "{{ url_for('paciente.mis_sesiones') }}";
            return;
        }

        lastButtonStates = states;
        requestAnimationFrame(pollGamepad);
    }

    // SINCRONIZACI√ìN CON PROFESIONAL
    function startPollingEstadoSesion() {
        console.log("üîÑ Iniciando polling cada 2 segundos...");
        comprobarEstadoSesion();
        setInterval(comprobarEstadoSesion, 2000);
    }

    async function comprobarEstadoSesion() {
        if (cambioEnProceso) {
            console.log('‚è∏Ô∏è Cambio en proceso, saltando polling...');
            return;
        }

        try {
            const resp = await fetch(`/profesional/api/sesion/${sesionId}/estado`);
            if (!resp.ok) {
                console.warn("‚ö†Ô∏è Error:", resp.status);
                return;
            }

            const data = await resp.json();
            console.log("Estado recibido:", data);

            // Sesi√≥n terminada
            if (data.terminada) {
                isSessionActive = false;
                waitingOverlay.classList.remove('d-none');
                ejercicioNombre.textContent = 'Sesi√≥n finalizada por tu terapeuta';
                ejercicioTipo.textContent = '';
                demoVideo.pause();

                // Cortar solo si sigue grabando y este ejercicio no est√° marcado como completado
                if (mediaRecorder &&
                    mediaRecorder.state === 'recording' &&
                    currentExerciseId &&
                    !ejerciciosCompletados.has(currentExerciseId)) {
                    stopRecording();
                }

                setTimeout(() => {
                    window.location.href = "{{ url_for('paciente.dashboard') }}";
                }, 2000);
                return;
            }

            const ejercicioActivoId = data.ejercicio_activo_id;
            const now = Date.now();

            // 1) Si el backend manda un id de ejercicio YA COMPLETADO, lo ignoramos
            if (ejercicioActivoId != null && ejerciciosCompletados.has(ejercicioActivoId)) {
                console.log("üîÅ Id ya completado, se ignora:", ejercicioActivoId);
                return;
            }

            // 2) SIN EJERCICIO ACTIVO (null) -> ignorar siempre
            if (ejercicioActivoId == null) {
                console.log("‚è≥ Sin ejercicio activo (ignorado)");
                candidatoId = null;
                pollsMismoId = 0;
                return;
            }

            // 3) Si el id es el mismo que el √∫ltimo aceptado, no hacer nada
            if (ejercicioActivoId === ultimoEjercicioRecibido) {
                return;
            }

            // 4) Estabilizaci√≥n del nuevo id
            if (candidatoId === ejercicioActivoId) {
                pollsMismoId += 1;
            } else {
                candidatoId = ejercicioActivoId;
                pollsMismoId = 1;
            }
            console.log(`üîç Visto nuevo id ${candidatoId} (${pollsMismoId} veces seguidas)`);

            if (pollsMismoId < REQUIRED_STABLE_POLLS) {
                return;
            }

            // 5) Intervalo m√≠nimo entre cambios reales de ejercicio
            if (ultimoEjercicioRecibido !== null &&
                (now - lastChangeTime) < MIN_CHANGE_INTERVAL) {
                console.log("Cambio ignorado por intervalo m√≠nimo:", candidatoId);
                return;
            }

            if (candidatoId == null) {
                console.log("‚ùå candidatoId es null, se ignora cambio");
                return;
            }

            const index = ejercicios.findIndex(ej => ej.Id === candidatoId);
            if (index === -1) {
                console.error(`‚ùå Ejercicio ${candidatoId} no encontrado en la lista`);
                return;
            }

            // Si el backend manda el mismo ejercicio que ya estoy mostrando, no recargo demo
            if (index === currentExercise) {
                console.log("üîÅ Mismo ejercicio ya cargado, se ignora cambio.");
                return;
            }

            // Si estamos grabando y el bloqueo est√° activo, NO cambiar de demo ni de ejercicio
            if (lockCambioEjercicio) {
                console.log("üîí Grabaci√≥n en curso; se ignora cambio de ejercicio:", candidatoId);
                return;
            }

            // Vamos a cambiar de ejercicio
            cambioEnProceso = true;
            pollsMismoId = 0;
            lastChangeTime = now;

            // Si ya hab√≠a un ejercicio anterior y no est√° completado, cortar antes de cambiar
            if (ultimoEjercicioRecibido !== null &&
                !ejerciciosCompletados.has(ultimoEjercicioRecibido) &&
                mediaRecorder &&
                mediaRecorder.state === 'recording') {
                stopRecording();                  // dispara uploadVideo()
                await new Promise(r => setTimeout(r, 500));
            }

            if (!isSessionActive) {
                console.log("üé¨ Iniciando sesi√≥n por primera vez...");
                isSessionActive = true;
                waitingOverlay.classList.add('d-none');
                document.getElementById('exitButton').style.display = 'none';
            }

            // Guardar id real que ha marcado el profesional
            ultimoEjercicioRecibido = candidatoId;
            currentExerciseId = candidatoId;

            console.log(`üéØ Cambiando a ejercicio con Id ${candidatoId}`);
            await loadExercise(index);
            cambioEnProceso = false;

        } catch (e) {
            console.error("‚ùå Error en polling:", e);
            cambioEnProceso = false;
        }
    }

    // L√ìGICA DE EJERCICIOS
    async function loadExercise(index) {
        if (index >= totalExercises) {
            endSession();
            return;
        }

        console.log(`üéØ Cargando ejercicio ${index + 1}/${totalExercises}`);
        currentExercise = index;

        const ejercicio = ejercicios[index];

        // Asegurar el id de Ejercicio_Sesion asociado a este √≠ndice
        currentExerciseId = ejercicio.Id;

        // Actualizar t√≠tulo inmediatamente
        ejercicioNombre.textContent = ejercicio.ejercicio.Nombre;
        ejercicioTipo.textContent = ejercicio.ejercicio.Tipo;

        // Limpiar completamente el video anterior
        console.log('üßπ Limpiando video anterior...');
        demoVideo.pause();
        demoVideo.removeAttribute('src');
        demoVideo.load();
       
        await new Promise(resolve => setTimeout(resolve, 300));

        // Determinar ruta del video
        let videoSrc = ejercicio.ejercicio.Video;
        if (videoSrc.startsWith('ejercicio_')) {
            videoSrc = "/static/uploads/ejercicios/" + videoSrc;
        } else if (!videoSrc.startsWith('/static/')) {
            videoSrc = "/static/videos/" + videoSrc;
        }

        console.log(`üìπ Cargando nuevo video: ${videoSrc}`);
       
        demoVideo.src = videoSrc;
        demoVideo.load();

        return new Promise((resolve) => {
            let timeoutId;
           
            const onCanPlay = async () => {
                clearTimeout(timeoutId);
                demoVideo.removeEventListener('canplay', onCanPlay);
               
                try {
                    await demoVideo.play();
                    console.log('‚úÖ Video demo reproduciendo correctamente');
                   
                    await new Promise(r => setTimeout(r, 1000));
                    startRecording();
                    resolve();
                } catch (err) {
                    console.error('‚ùå Error reproduciendo video:', err);
                    startRecording();
                    resolve();
                }
            };

            demoVideo.addEventListener('canplay', onCanPlay);

            // Timeout de seguridad (5 segundos)
            timeoutId = setTimeout(() => {
                demoVideo.removeEventListener('canplay', onCanPlay);
                console.warn('‚ö†Ô∏è Timeout esperando video, forzando inicio');
                demoVideo.play().catch(console.error);
                startRecording();
                resolve();
            }, 5000);
        });
    }

    function startRecording() {
        if (!cameraPreview.srcObject) {
            console.warn("No hay stream de c√°mara disponible para grabar.");
            return;
        }

        // si ya hay un mediaRecorder grabando, no iniciar otro
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            console.warn("Ya hay una grabaci√≥n en curso, se ignora startRecording.");
            return;
        }

        try {
            mediaRecorder = new MediaRecorder(cameraPreview.srcObject);
            recordedChunks = [];
            stopAlreadyCalled = false;  // reset para esta grabaci√≥n
            lockCambioEjercicio = true; // BLOQUEAR cambios mientras se graba

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = uploadVideo;

            mediaRecorder.start();
            recordingStatus.classList.remove('d-none');
            timerDisplay.classList.remove('d-none');

            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
        } catch (err) {
            console.error("Error al iniciar grabaci√≥n:", err);
            lockCambioEjercicio = false; // por si falla
        }
    }

    function stopRecording() {
        if (!mediaRecorder) return;

        // Evitar m√∫ltiples stop() por la misma grabaci√≥n
        if (stopAlreadyCalled) {
            console.warn("stopRecording ya fue llamado para esta grabaci√≥n, se ignora.");
            return;
        }
        stopAlreadyCalled = true;

        if (mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
        }

        lockCambioEjercicio = false;  // PERMITIR cambios cuando termina la grabaci√≥n

        recordingStatus.classList.add('d-none');
        timerDisplay.classList.add('d-none');
        clearInterval(timerInterval);
        timer.textContent = "00:00";
    }

    function updateTimer() {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const seconds = (elapsed % 60).toString().padStart(2, '0');
        timer.textContent = `${minutes}:${seconds}`;
    }

    async function uploadVideo() {
        if (recordedChunks.length === 0) return;
        if (!currentExerciseId) {
            console.warn("No hay currentExerciseId, no se sube v√≠deo.");
            return;
        }

        const ejercicioSesionId = currentExerciseId;

        // Si este ejercicio ya est√° marcado como completado, no subas nada
        if (ejerciciosCompletados.has(ejercicioSesionId)) {
            console.warn("Ejercicio ya completado, se ignora uploadVideo:", ejercicioSesionId);
            return;
        }

        // Si ya se inici√≥ una subida para este ejercicio en esta sesi√≥n, no iniciar otra
        if (ejerciciosSubidosEnEstaSesion.has(ejercicioSesionId)) {
            console.warn("Ya se inici√≥ una subida para este ejercicio en esta sesi√≥n, se ignora:", ejercicioSesionId);
            return;
        }
        ejerciciosSubidosEnEstaSesion.add(ejercicioSesionId);

        if (isUploading) {
            console.warn("Ya hay una subida en curso, se ignora esta llamada.");
            return;
        }
        isUploading = true;

        console.log("‚è´ Subiendo v√≠deo de ejercicio", ejercicioSesionId);

        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const formData = new FormData();
        formData.append('video', blob, `respuesta_${ejercicioSesionId}.webm`);

        try {
            const response = await fetch(`/profesional/guardar_video/${ejercicioSesionId}`, {
                method: 'POST',
                body: formData
            });

            if (response.ok) {
                let msg = '';
                try {
                    const data = await response.json();
                    msg = data.mensaje || '';
                } catch (e) {}
                console.log('Video aceptado por el servidor:', msg);
                ejerciciosCompletados.add(ejercicioSesionId);
            } else {
                const txt = await response.text();
                console.warn('Error HTTP al subir video:', response.status, txt);
            }
        } catch (error) {
            console.error('Error subiendo video:', error);
        } finally {
            isUploading = false;
        }
    }

    function endSession() {
        isSessionActive = false;
        ejercicioNombre.textContent = '¬°Sesi√≥n completada!';
        ejercicioTipo.textContent = 'Excelente trabajo';

        setTimeout(() => {
            window.location.href = "{{ url_for('paciente.dashboard') }}";
        }, 3000);
    }

    function showAlert(message) {
        console.log(message);
    }
});
</script>
{% endblock %}

{% endblock %}
