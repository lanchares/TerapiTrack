{% extends "base.html" %}

{% block title %}Sesión en Curso - TerapiTrack{% endblock %}

{% block content %}
<div class="container-fluid p-0" style="height: 100vh; background: #000;">
    <div class="row g-0 h-100">
        <!-- Panel izquierdo: vídeo demostración del ejercicio -->
        <div class="col-md-6 h-100 position-relative">
            <div class="h-100 d-flex flex-column" style="min-height:0;">
                <!-- Cabecera del vídeo de demostración -->
                <div class="bg-primary text-white p-3 text-center">
                    <h4 class="mb-0" id="ejercicioNombre">Esperando al profesional...</h4>
                    <small id="ejercicioTipo" class="text-light"></small>
                </div>

                <!-- Zona principal del vídeo de demostración -->
                <div class="flex-grow-1 position-relative" style="min-height:0;">
                    <video id="demoVideo" controls autoplay muted loop
                           class="w-100 h-100"
                           style="object-fit: cover; background: #1a1a1a; max-height:100%;">
                        <source src="" type="video/mp4">
                        Tu navegador no soporta videos.
                    </video>

                    <!-- Capa de espera mientras el terapeuta no ha iniciado la sesión -->
                    <div id="waitingOverlay" class="position-absolute top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center bg-dark bg-opacity-75">
                        <div class="text-center text-white">
                            <div class="spinner-border text-primary mb-3" role="status">
                                <span class="visually-hidden">Cargando...</span>
                            </div>
                            <h5>Esperando al profesional</h5>
                            <p class="text-muted">Tu terapeuta iniciará la sesión en breve</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Panel derecho: cámara del paciente y estado del mando -->
        <div class="col-md-6 h-100 position-relative">
            <div class="h-100 d-flex flex-column">
                <!-- Cabecera de la cámara del paciente -->
                <div class="bg-success text-white p-3 text-center">
                    <h4 class="mb-0">Tu ejecución</h4>
                    <div id="recordingStatus" class="d-none">
                        <span class="recording-dot"></span>
                        <small>GRABANDO</small>
                    </div>
                </div>

                <!-- Vista previa de la cámara del paciente -->
                <div class="flex-grow-1 position-relative">
                    <video id="cameraPreview" autoplay playsinline muted
                           class="w-100 h-100"
                           style="object-fit: cover; background: #1a1a1a;"></video>

                    <!-- Temporizador de la grabación de respuesta -->
                    <div id="timerDisplay" class="position-absolute top-0 end-0 bg-dark bg-opacity-75 text-white p-2 rounded-bottom-start d-none">
                        <i class="bi bi-stopwatch me-1"></i>
                        <span id="timer">00:00</span>
                    </div>
                </div>

                <!-- Representación resumida del estado del mando SNES -->
                <div class="bg-dark text-white p-2">
                    <div class="d-flex justify-content-center">
                        <div class="mini-snes-controller">
                            <!-- Colores correctos: Y verde, X azul, B amarillo, A roja -->
                            <div class="mini-snes-button" id="mini-y" style="background: #4CAF50;">Y</div>
                            <div class="mini-snes-button" id="mini-x" style="background: #2196F3;">X</div>
                            <div class="mini-snes-button" id="mini-b" style="background: #FFC107;">B</div>
                            <div class="mini-snes-button" id="mini-a" style="background: #F44336;">A</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Botón para salir mientras aún no se ha iniciado la sesión activa -->
    <div class="position-absolute top-0 end-0 p-3" id="exitButton">
        <a href="{{ url_for('paciente.dashboard') }}" class="btn btn-outline-light">
            <i class="bi bi-x-lg"></i>
        </a>
    </div>
</div>

{% endblock %} 

{% block style %}

<style>
    /* Punto rojo indicador de grabación en curso */
    .recording-dot {
        display: inline-block;
        width: 8px;
        height: 8px;
        background-color: #dc3545;
        border-radius: 50%;
        margin-right: 8px;
        animation: blink 1s infinite;
    }

    @keyframes blink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0.3; }
    }

    /* Contenedor del mini mando SNES */
    .mini-snes-controller {
        display: flex;
        gap: 8px;
        align-items: center;
    }

    /* Botones del mini mando */
    .mini-snes-button {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 0.7rem;
        font-weight: bold;
        transition: transform 0.1s;
        opacity: 0.6;
    }

    /* Estado cuando el botón está siendo pulsado en el mando real */
    .mini-snes-button.active {
        opacity: 1;
        transform: scale(1.2);
    }
</style>

{% endblock %}

{% block scripts %}

<script>
document.addEventListener("DOMContentLoaded", function() {
    // Referencias a elementos de la interfaz de vídeo y cámara
    const cameraPreview = document.getElementById('cameraPreview');
    const demoVideo = document.getElementById('demoVideo');
    const ejercicioNombre = document.getElementById('ejercicioNombre');
    const ejercicioTipo = document.getElementById('ejercicioTipo');
    const recordingStatus = document.getElementById('recordingStatus');
    const timerDisplay = document.getElementById('timerDisplay');
    const timer = document.getElementById('timer');
    const waitingOverlay = document.getElementById('waitingOverlay');

    // Referencias al mini mando visual
    const miniButtons = {
        'Y': document.getElementById('mini-y'),
        'X': document.getElementById('mini-x'),
        'B': document.getElementById('mini-b'),
        'A': document.getElementById('mini-a')
    };

    // Datos de ejercicios y sesión que vienen del backend
    const ejercicios = {{ ejercicios_json|tojson }};
    const sesionId = {{ sesion.Id }};

    console.log("Ejercicios cargados del paciente:", ejercicios);
    console.log("Sesión ID:", sesionId);

    // Variables de estado de la sesión y grabación
    let isSessionActive = false;
    let mediaRecorder = null;
    let recordedChunks = [];
    let startTime;
    let timerInterval;
    let currentExercise = -1;      // índice en el array de ejercicios
    let currentExerciseId = null;  // Id de EjercicioSesion actual
    const totalExercises = ejercicios.length;

    // Parámetros de estabilización de cambios de ejercicio recibidos del profesional
    let ultimoEjercicioRecibido = null;   // último id aceptado
    let candidatoId = null;               // id que se está comprobando
    let pollsMismoId = 0;                 // número de polls consecutivos con el mismo id candidato
    const REQUIRED_STABLE_POLLS = 2;
    const MIN_CHANGE_INTERVAL = 8000;     // milisegundos mínimos entre cambios aceptados
    let lastChangeTime = 0;
    let cambioEnProceso = false;

    // Control de subidas para evitar duplicados
    let isUploading = false;
    const ejerciciosCompletados = new Set();           // ejercicios con vídeo ya subido
    const ejerciciosSubidosEnEstaSesion = new Set();   // ejercicios que ya han iniciado subida en esta sesión

    // Flags para evitar dobles llamadas a stop/onstop
    let stopAlreadyCalled = false;
    let lockCambioEjercicio = false;
    let onStopHandled = false;

    // Estado del mando y memoria del último frame
    let gamepadIndex = null;
    let lastButtonStates = { Y: false, X: false, B: false, A: false };

    // Inicio de cámara, mando y polling del estado de la sesión
    initCamera();
    initGamepad();
    startPollingEstadoSesion();

    // Inicializa la cámara del paciente
    async function initCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 1280, height: 720 },
                audio: true
            });
            cameraPreview.srcObject = stream;
            console.log("Cámara inicializada correctamente");
        } catch (err) {
            console.error("Error al acceder a la cámara:", err);
            showAlert("Error al acceder a la cámara. Verifica los permisos.");
        }
    }

    // Inicializa escuchas del Gamepad (mando)
    function initGamepad() {
        window.addEventListener('gamepadconnected', (e) => {
            gamepadIndex = e.gamepad.index;
            console.log('Mando conectado (ejecutar_sesion):', e.gamepad.id);
            requestAnimationFrame(pollGamepad);
        });

        window.addEventListener('gamepaddisconnected', () => {
            console.log('Mando desconectado (ejecutar_sesion)');
            gamepadIndex = null;
            Object.values(miniButtons).forEach(btn => btn && btn.classList.remove('active'));
        });
    }

    // Lee el estado del mando en bucle y actualiza la UI
    function pollGamepad() {
        if (gamepadIndex === null) return;

        const pads = navigator.getGamepads();
        const gp = pads[gamepadIndex];
        if (!gp) {
            requestAnimationFrame(pollGamepad);
            return;
        }

        // Mapping adaptado: 0=X, 1=A, 2=B, 3=Y
        const btnX = gp.buttons[0]?.pressed || false;
        const btnA = gp.buttons[1]?.pressed || false;
        const btnB = gp.buttons[2]?.pressed || false;
        const btnY = gp.buttons[3]?.pressed || false;

        const states = { A: btnA, B: btnB, X: btnX, Y: btnY };

        // Actualizar mini mando visual según botones pulsados
        Object.keys(miniButtons).forEach(letter => {
            const el = miniButtons[letter];
            if (!el) return;
            if (states[letter]) el.classList.add('active');
            else el.classList.remove('active');
        });

        // Mientras la sesión no está activa, permitir salir con Y hacia el listado de sesiones
        if (!isSessionActive && states.Y && !lastButtonStates.Y) {
            window.location.href = "{{ url_for('paciente.mis_sesiones') }}";
            return;
        }

        lastButtonStates = states;
        requestAnimationFrame(pollGamepad);
    }

    // Inicia el polling periódico del estado de la sesión frente al backend
    function startPollingEstadoSesion() {
        console.log("Iniciando polling de estado de sesión cada 2 segundos...");
        comprobarEstadoSesion();
        setInterval(comprobarEstadoSesion, 2000);
    }

    // Consulta al backend qué ejercicio está activo y si la sesión ha terminado
    async function comprobarEstadoSesion() {
        if (cambioEnProceso) {
            console.log('Cambio de ejercicio en proceso, se omite este ciclo de polling.');
            return;
        }

        try {
            const resp = await fetch(`/profesional/api/sesion/${sesionId}/estado`);
            if (!resp.ok) {
                console.warn("Respuesta HTTP no exitosa:", resp.status);
                return;
            }

            const data = await resp.json();
            console.log("Estado de sesión recibido:", data);

            // Gestión de sesión terminada desde el profesional
            if (data.terminada) {
                isSessionActive = false;
                waitingOverlay.classList.remove('d-none');
                ejercicioNombre.textContent = 'Sesión finalizada por tu terapeuta';
                ejercicioTipo.textContent = '';
                demoVideo.pause();

                // Detener grabación solo si sigue activa y el ejercicio no está ya marcado
                if (mediaRecorder &&
                    mediaRecorder.state === 'recording' &&
                    currentExerciseId &&
                    !ejerciciosCompletados.has(currentExerciseId)) {
                    stopRecording();
                }

                setTimeout(() => {
                    window.location.href = "{{ url_for('paciente.dashboard') }}";
                }, 2000);
                return;
            }

            const ejercicioActivoId = data.ejercicio_activo_id;
            const now = Date.now();

            // Ignorar ids de ejercicios ya completados
            if (ejercicioActivoId != null && ejerciciosCompletados.has(ejercicioActivoId)) {
                console.log("Id de ejercicio ya completado, se ignora:", ejercicioActivoId);
                return;
            }

            // Si no hay ejercicio activo definido, se ignora
            if (ejercicioActivoId == null) {
                console.log("Sin ejercicio activo informado por el servidor (ignorado).");
                candidatoId = null;
                pollsMismoId = 0;
                return;
            }

            // Si coincide con el último aceptado, no hay cambio
            if (ejercicioActivoId === ultimoEjercicioRecibido) {
                return;
            }

            // Estabilidad: contar cuántas veces consecutivas llega el mismo id
            if (candidatoId === ejercicioActivoId) {
                pollsMismoId += 1;
            } else {
                candidatoId = ejercicioActivoId;
                pollsMismoId = 1;
            }
            console.log(`Visto nuevo id candidato ${candidatoId} (${pollsMismoId} veces seguidas).`);

            if (pollsMismoId < REQUIRED_STABLE_POLLS) {
                return;
            }

            // Intervalo mínimo entre cambios reales de ejercicio
            if (ultimoEjercicioRecibido !== null &&
                (now - lastChangeTime) < MIN_CHANGE_INTERVAL) {
                console.log("Cambio ignorado por intervalo mínimo entre ejercicios:", candidatoId);
                return;
            }

            if (candidatoId == null) {
                console.log("candidatoId es null, se ignora cambio.");
                return;
            }

            const index = ejercicios.findIndex(ej => ej.Id === candidatoId);
            if (index === -1) {
                console.error(`Ejercicio con Id ${candidatoId} no encontrado en la lista local.`);
                return;
            }

            // Si ya estamos mostrando ese índice, no recargamos
            if (index === currentExercise) {
                console.log("Ejercicio ya cargado, no se fuerza recarga de demo.");
                return;
            }

            // Si estamos grabando y se intenta saltar a ejercicio ya completado, se bloquea
            if (lockCambioEjercicio &&
                mediaRecorder &&
                mediaRecorder.state === 'recording' &&
                ejerciciosCompletados.has(candidatoId)) {
                console.log("Grabación en curso; se ignora salto a ejercicio ya completado:", candidatoId);
                return;
            }

            // A partir de aquí se acepta el cambio
            cambioEnProceso = true;
            pollsMismoId = 0;
            lastChangeTime = now;

            // Si había un ejercicio anterior sin completar y se está grabando, detén antes de cambiar
            if (ultimoEjercicioRecibido !== null &&
                !ejerciciosCompletados.has(ultimoEjercicioRecibido) &&
                mediaRecorder &&
                mediaRecorder.state === 'recording') {
                stopRecording();
                await new Promise(r => setTimeout(r, 500));
            }

            // Primera activación de la sesión: ocultar overlay y botón de salir
            if (!isSessionActive) {
                console.log("Sesión activada por primera vez.");
                isSessionActive = true;
                waitingOverlay.classList.add('d-none');
                document.getElementById('exitButton').style.display = 'none';
            }

            // Guardar id definitivo enviado por el profesional
            ultimoEjercicioRecibido = candidatoId;
            currentExerciseId = candidatoId;

            console.log(`Cambiando a ejercicio con Id ${candidatoId}.`);
            await loadExercise(index);
            cambioEnProceso = false;

        } catch (e) {
            console.warn("Error en polling de sesión (posible navegación o problema de red):", e);
            cambioEnProceso = false;
        }
    }

    // Carga el ejercicio indicado y sincroniza vídeo demostrativo y grabación
    async function loadExercise(index) {
        if (index >= totalExercises) {
            endSession();
            return;
        }

        console.log(`Cargando ejercicio ${index + 1} de ${totalExercises}.`);
        currentExercise = index;

        const ejercicio = ejercicios[index];

        // Id de EjercicioSesion asociado a este índice
        currentExerciseId = ejercicio.Id;

        // Actualizar texto del encabezado de ejercicio
        ejercicioNombre.textContent = ejercicio.ejercicio.Nombre;
        ejercicioTipo.textContent = ejercicio.ejercicio.Tipo;

        // Limpiar completamente el vídeo anterior antes de cargar uno nuevo
        console.log('Limpiando vídeo de demostración anterior.');
        demoVideo.pause();
        demoVideo.removeAttribute('src');
        demoVideo.load();

        await new Promise(resolve => setTimeout(resolve, 300));

        // Construir la ruta del archivo de vídeo según su nombre
        let videoSrc = ejercicio.ejercicio.Video;
        if (videoSrc.startsWith('ejercicio_')) {
            videoSrc = "/static/uploads/ejercicios/" + videoSrc;
        } else if (!videoSrc.startsWith('/static/')) {
            videoSrc = "/static/videos/" + videoSrc;
        }

        console.log(`Cargando nuevo vídeo de demostración: ${videoSrc}`);

        demoVideo.src = videoSrc;
        demoVideo.load();

        // Esperar a que el vídeo esté listo (o timeout) y después iniciar grabación
        return new Promise((resolve) => {
            let timeoutId;

            const onCanPlay = async () => {
                clearTimeout(timeoutId);
                demoVideo.removeEventListener('canplay', onCanPlay);

                try {
                    await demoVideo.play();
                    console.log('Vídeo de demostración en reproducción.');

                    await new Promise(r => setTimeout(r, 1000));
                    startRecording();
                    resolve();
                } catch (err) {
                    console.error('Error al reproducir vídeo de demostración:', err);
                    startRecording();
                    resolve();
                }
            };

            demoVideo.addEventListener('canplay', onCanPlay);

            // Timeout de seguridad de 5 segundos para evitar bloqueo si canplay no se dispara
            timeoutId = setTimeout(() => {
                demoVideo.removeEventListener('canplay', onCanPlay);
                console.warn('Timeout esperando al vídeo; se fuerza inicio de reproducción y grabación.');
                demoVideo.play().catch(console.error);
                startRecording();
                resolve();
            }, 5000);
        });
    }

    // Inicia la grabación de la cámara del paciente
    function startRecording() {
        if (!cameraPreview.srcObject) {
            console.warn("No hay flujo de cámara disponible para iniciar grabación.");
            return;
        }

        // Evitar iniciar más de una grabación a la vez
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            console.warn("Ya hay una grabación en curso; se ignora startRecording.");
            return;
        }

        try {
            mediaRecorder = new MediaRecorder(cameraPreview.srcObject);
            recordedChunks = [];        // limpiar buffer
            stopAlreadyCalled = false;  // reset para esta grabación
            lockCambioEjercicio = true; // bloquear cambios a ejercicios completados durante la grabación
            onStopHandled = false;      // reset del flag de onstop

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            // onstop se asegura de invocar uploadVideo solo una vez
            mediaRecorder.onstop = () => {
                if (onStopHandled) {
                    console.warn("Evento onstop ya procesado anteriormente; se ignora.");
                    return;
                }
                onStopHandled = true;
                uploadVideo();
            };

            mediaRecorder.start();
            recordingStatus.classList.remove('d-none');
            timerDisplay.classList.remove('d-none');

            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
        } catch (err) {
            console.error("Error al iniciar la grabación de vídeo:", err);
            lockCambioEjercicio = false;
        }
    }

    // Detiene la grabación (si está activa) y actualiza estado visual
    function stopRecording() {
        if (!mediaRecorder) return;

        // Evitar llamadas múltiples a stop() para la misma grabación
        if (stopAlreadyCalled) {
            console.warn("stopRecording ya fue llamado para esta grabación; se ignora.");
            return;
        }
        stopAlreadyCalled = true;

        if (mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
        }

        // Al parar se permite de nuevo el cambio de ejercicio
        lockCambioEjercicio = false;

        recordingStatus.classList.add('d-none');
        timerDisplay.classList.add('d-none');
        clearInterval(timerInterval);
        timer.textContent = "00:00";
    }

    // Actualiza el contador de tiempo de grabación mostrado al paciente
    function updateTimer() {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const seconds = (elapsed % 60).toString().padStart(2, '0');
        timer.textContent = `${minutes}:${seconds}`;
    }

    // Sube el vídeo grabado al servidor para el ejercicio actual
    async function uploadVideo() {
        if (!recordedChunks || recordedChunks.length === 0) return;
        if (!currentExerciseId) {
            console.warn("No hay currentExerciseId; no se sube vídeo.");
            return;
        }

        const ejercicioSesionId = currentExerciseId;

        // No repetir subida si el ejercicio ya está marcado como completado
        if (ejerciciosCompletados.has(ejercicioSesionId)) {
            console.warn("Ejercicio ya completado; uploadVideo se omite para:", ejercicioSesionId);
            return;
        }

        // No iniciar más de una subida para el mismo ejercicio en esta sesión
        if (ejerciciosSubidosEnEstaSesion.has(ejercicioSesionId)) {
            console.warn("Ya se inició subida para este ejercicio en esta sesión; se omite:", ejercicioSesionId);
            return;
        }
        ejerciciosSubidosEnEstaSesion.add(ejercicioSesionId);

        if (isUploading) {
            console.warn("Ya hay una subida en curso; se ignora esta llamada.");
            return;
        }
        isUploading = true;

        console.log("Subiendo vídeo de ejercicio con Id:", ejercicioSesionId);

        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const formData = new FormData();
        formData.append('video', blob, `respuesta_${ejercicioSesionId}.webm`);

        try {
            const response = await fetch(`/profesional/guardar_video/${ejercicioSesionId}`, {
                method: 'POST',
                body: formData
            });

            if (response.ok) {
                let msg = '';
                try {
                    const data = await response.json();
                    msg = data.mensaje || '';
                } catch (e) {}
                console.log('Vídeo aceptado por el servidor:', msg);
                ejerciciosCompletados.add(ejercicioSesionId);
            } else {
                const txt = await response.text();
                console.warn('Error HTTP al subir vídeo:', response.status, txt);
            }
        } catch (error) {
            console.warn('Error subiendo vídeo (posible problema de red o navegación):', error);
        } finally {
            isUploading = false;
        }
    }

    // Marca el final de la sesión y redirige tras una breve pausa
    function endSession() {
        isSessionActive = false;
        ejercicioNombre.textContent = 'Sesión completada';
        ejercicioTipo.textContent = 'Buen trabajo';

        setTimeout(() => {
            window.location.href = "{{ url_for('paciente.dashboard') }}";
        }, 3000);
    }

    // Utilidad básica para mostrar mensajes (actualmente a consola)
    function showAlert(message) {
        console.log(message);
    }
});
</script>

{% endblock %}
